import cv2
import numpy as np
import random
import mediapipe as mp
import imageio

mp_drawing = mp.solutions.drawing_utils
mp_hands = mp.solutions.hands

# Detect if a rectangle is overlapping with the hand
def is_hand_overlapping(hand_x, hand_y, rect):
    x, y, w, h = rect
    if hand_x > x and hand_x < x + w and hand_y > y and hand_y < y + h:
        return True
    return False

# Remove rectangles that are overlapping with the hand
def remove_overlapping_rectangles(hand_x, hand_y, rectangles):
    return [rect for rect in rectangles if not is_hand_overlapping(hand_x, hand_y, rect)]

# Initialize MediaPipe hands module
mp_drawing_styles = mp.solutions.drawing_styles

# Create initial rectangles
rectangles = [(random.randint(0, 640-50), random.randint(0, 360-50), 50, 50) for _ in range(5)]

# Load GIF frames
gif = imageio.mimread('虫子.png', memtest=False)
gif_frames = [cv2.cvtColor(frame, cv2.COLOR_RGB2BGRA) for frame in gif]  # Convert frames to include alpha channel
frame_count = len(gif_frames)
current_frame = 0

with mp_hands.Hands(
    model_complexity=0,
    min_detection_confidence=0.5,
    min_tracking_confidence=0.5) as hands:
    cap = cv2.VideoCapture(0)

    if not cap.isOpened():
        print("Cannot open camera")
        exit()

    cv2.namedWindow('Frame', cv2.WND_PROP_FULLSCREEN)
    cv2.setWindowProperty('Frame', cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)

    while True:
        ret, frame = cap.read()
        if not ret:
            print("Cannot receive frame")
            break

        frame = cv2.resize(frame, (640, 360))
        frame_height, frame_width, _ = frame.shape
        center_x, center_y = frame_width // 2, frame_height // 2

        img_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = hands.process(img_rgb)

        if results.multi_hand_landmarks:
            for hand_landmarks in results.multi_hand_landmarks:
                fingertip_x = hand_landmarks.landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP].x * frame_width
                fingertip_y = hand_landmarks.landmark[mp_hands.HandLandmark.INDEX_FINGER_TIP].y * frame_height

                rectangles = remove_overlapping_rectangles(fingertip_x, fingertip_y, rectangles)

                mp_drawing.draw_landmarks(
                    frame,
                    hand_landmarks,
                    mp_hands.HAND_CONNECTIONS,
                    mp_drawing_styles.get_default_hand_landmarks_style(),
                    mp_drawing_styles.get_default_hand_connections_style())

        for i, rect in enumerate(rectangles):
            x, y, w, h = rect

            cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)

            # Move rectangles towards the center
            if x < center_x:
                x += 1
            elif x > center_x:
                x -= 1
            if y < center_y:
                y += 1
            elif y > center_y:
                y -= 1

            # Resize the GIF frame to fit inside the rectangle
            overlay = cv2.resize(gif_frames[current_frame], (w, h))

            # Calculate the position to place the GIF frame
            gif_x = x + w // 2 - overlay.shape[1] // 2
            gif_y = y + h // 2 - overlay.shape[0] // 2

            # Ensure the coordinates are within the frame boundaries
            gif_x = max(gif_x, 0)
            gif_y = max(gif_y, 0)

            overlay_h, overlay_w, _ = overlay.shape

            # Adjust the overlay dimensions if they exceed frame boundaries
            if gif_y + overlay_h > frame_height:
                overlay = overlay[:frame_height - gif_y, :, :]
            if gif_x + overlay_w > frame_width:
                overlay = overlay[:, :frame_width - gif_x, :]

            # Extract the alpha mask of the overlay
            alpha_mask = overlay[:, :, 3] / 255.0
            alpha_inv = 1.0 - alpha_mask

            # Ensure the overlay fits within the frame boundaries
            y1, y2 = gif_y, gif_y + overlay.shape[0]
            x1, x2 = gif_x, gif_x + overlay.shape[1]

            for c in range(0, 3):
                frame[y1:y2, x1:x2, c] = (alpha_mask * overlay[:, :, c] +
                                          alpha_inv * frame[y1:y2, x1:x2, c])

            rectangles[i] = (x, y, w, h)

        cv2.imshow('Frame', frame)

        current_frame = (current_frame + 1) % frame_count

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    cap.release()
    cv2.destroyAllWindows()
